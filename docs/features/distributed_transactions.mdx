---
title: 'Distributed Transactions'
description: 'How to use two-phase commit and understand transaction commit strategies in SPQR'
---

## Overview

SPQR supports distributed transactions across multiple shards with different commit strategies. Understanding when and how to use these strategies is essential for maintaining data consistency in your sharded PostgreSQL cluster.

## Commit Strategies

SPQR provides three commit strategies for distributed transactions, controlled by the `__spqr__commit_strategy` parameter:

### 1. Best-effort (Default)

**Value:** `best-effort`

This is the default commit strategy, functionally equivalent to `1pc` (one-phase commit). In this mode:

- Transactions are committed on each shard independently
- No coordination between shards during commit
- **Warning:** If a transaction spans multiple shards, partial commits are possible if one shard fails
- Best used for single-shard transactions or when eventual consistency is acceptable

**Example:**
```sql
-- Default behavior (no need to set explicitly)
BEGIN;
INSERT INTO users (id, name) VALUES (1, 'Alice');
COMMIT;
```

### 2. One-Phase Commit (1PC)

**Value:** `1pc`

This is an alias for `best-effort` mode. It commits transactions independently on each shard without coordination.

**Example:**
```sql
SET __spqr__commit_strategy TO '1pc';
BEGIN;
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO orders (id, user_id) VALUES (100, 1);
COMMIT;
```

**Limitations:**
- No atomicity guarantee across shards
- If the commit fails on one shard after succeeding on another, data becomes inconsistent
- Not recommended for critical multi-shard transactions

### 3. Two-Phase Commit (2PC)

**Value:** `2pc`

Two-phase commit ensures atomicity across multiple shards using PostgreSQL's prepared transaction feature.

**How 2PC Works:**

1. **Prepare Phase:** SPQR sends `PREPARE TRANSACTION` to all involved shards with a unique transaction ID
2. **Commit Phase:** If all shards successfully prepare, SPQR sends `COMMIT PREPARED` to each shard
3. **Rollback on Failure:** If any shard fails to prepare, SPQR rolls back the entire transaction

**Requirements:**
- Must enable `__spqr__engine_v2` (enhanced multishard processing)
- All shards must have `max_prepared_transactions` > 0 in their PostgreSQL configuration
- Only applies when transaction spans **more than one shard** (single-shard transactions use regular commit)

**Example:**
```sql
-- Session-level setting
SET __spqr__commit_strategy TO '2pc';

BEGIN;
-- Multi-shard transaction
INSERT INTO shard1_table (id, data) VALUES (1, 'data1');
INSERT INTO shard2_table (id, data) VALUES (2, 'data2');
COMMIT; -- Uses 2PC automatically
```

**Or use it for a specific transaction:**
```sql
BEGIN;
SET __spqr__commit_strategy TO '2pc';
INSERT INTO shard1_table (id, data) VALUES (1, 'data1');
INSERT INTO shard2_table (id, data) VALUES (2, 'data2');
COMMIT; /* __spqr__commit_strategy: 2pc */
```

**Important Notes:**
- 2PC provides atomicity but has performance overhead
- Prepared transactions consume resources on shards until committed or rolled back
- Monitor prepared transactions with `pg_prepared_xacts` on each shard
- Configure `max_prepared_transactions` based on your expected concurrent transaction volume

## Configuring max_prepared_transactions

To use 2PC, configure each PostgreSQL shard:

```sql
-- On each shard server
ALTER SYSTEM SET max_prepared_transactions = 100;
-- Restart PostgreSQL for the change to take effect
```

Or in `postgresql.conf`:
```
max_prepared_transactions = 100
```

## Routing Parameters for Transaction Control

### __spqr__default_route_behaviour

Controls whether multi-shard queries are allowed.

**Values:** `BLOCK`, `ALLOW`

**Default:** Configured in router settings (`query_routing.default_route_behaviour`)

This parameter determines what happens when SPQR cannot route a query to a single shard:

- `BLOCK`: Rejects queries that would need to execute on multiple shards (safer for consistency)
- `ALLOW`: Permits multi-shard queries to execute (useful for DDL and administrative queries)

**Example:**
```sql
-- Default behavior blocks multi-shard queries
DROP DATABASE prod;
-- ERROR: client processing error: 'DROP DATABASE prod': failed to match any datashard.

-- Allow multi-shard execution
DROP DATABASE prod /* __spqr__default_route_behaviour: allow */;
-- NOTICE: send query to shard(s) : shard1,shard2,shard3,shard4
```

**Use Cases:**
- `BLOCK`: Production environments where you want strict control over shard access
- `ALLOW`: Development, testing, or when executing DDL commands across all shards

### __spqr__scatter_query

Forces a query to execute on all shards in the cluster.

**Values:** `true`, `false`

**Default:** `false`

This parameter is useful when you need to run a query across all shards, regardless of sharding key:

**Example:**
```sql
-- Execute on all shards
SELECT COUNT(*) FROM users /* __spqr__scatter_query: true */;

-- Can also be set at session level
SET __spqr__scatter_query TO true;
SELECT * FROM users; -- Executes on all shards
RESET __spqr__scatter_query;
```

**Warning:** Scatter queries:
- Do not provide consistent cross-shard snapshots
- Can have significant performance impact on large clusters
- Should be used primarily for administrative or analytical purposes

## Transaction Behavior

### Virtual Transactions

When not connected to a shard, SPQR buffers transaction commands locally:

```sql
BEGIN;
SET __spqr__commit_strategy TO '2pc';
-- No shard connection yet, parameters buffered
INSERT INTO users (id, name) VALUES (1, 'Alice'); -- Connection established here
COMMIT;
```

### Transaction Block Level Parameters

The `__spqr__commit_strategy` parameter is transaction-block-level, meaning:

- Setting it within a transaction only affects that transaction
- After `COMMIT` or `ROLLBACK`, the value reverts to the session-level setting

**Example:**
```sql
-- Session level
SET __spqr__commit_strategy TO '2pc';
SHOW __spqr__commit_strategy;
-- Output: 2pc

BEGIN;
SET __spqr__commit_strategy TO '1pc';
SHOW __spqr__commit_strategy;
-- Output: 1pc
ROLLBACK;

SHOW __spqr__commit_strategy;
-- Output: 2pc (reverted to session level)
```

## Best Practices

1. **Choose the Right Strategy:**
   - Use `1pc`/`best-effort` for single-shard transactions or when eventual consistency is acceptable
   - Use `2pc` only when you need strict atomicity across shards and can afford the performance cost

2. **Configure max_prepared_transactions:**
   - Set it higher than your peak concurrent transaction count
   - Monitor `pg_prepared_xacts` to ensure prepared transactions are being cleaned up

3. **Monitor Transaction Status:**
   - Check for orphaned prepared transactions on shards
   - Use `SELECT * FROM pg_prepared_xacts;` on each shard

4. **Design for Single-Shard Transactions:**
   - Whenever possible, design your application to keep transactions within a single shard
   - Use consistent sharding keys to co-locate related data

5. **Test Failure Scenarios:**
   - Test what happens when a shard fails during 2PC prepare phase
   - Have procedures for manual intervention if needed

## Examples

### Example 1: Safe Multi-Shard Update with 2PC

```sql
-- Enable 2PC for the session
SET __spqr__commit_strategy TO '2pc';

BEGIN;
UPDATE users SET status = 'active' WHERE id = 1; -- Shard 1
UPDATE orders SET processed = true WHERE user_id = 1; -- Shard 2
COMMIT; -- Uses 2PC if both shards are involved
```

### Example 2: Administrative Query Across All Shards

```sql
-- Allow multi-shard execution and broadcast query
SELECT version() 
/* __spqr__default_route_behaviour: allow, __spqr__scatter_query: true */;
```

### Example 3: DDL Command on All Shards

```sql
-- Create a table on all shards
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    event_time TIMESTAMP DEFAULT NOW(),
    event_type TEXT
) /* __spqr__default_route_behaviour: allow, __spqr__auto_distribution: REPLICATED */;
```

## Troubleshooting

### Issue: 2PC Not Working

**Symptom:** Transactions don't use 2PC even when configured

**Solutions:**
1. Verify `__spqr__engine_v2` is enabled
2. Check that `max_prepared_transactions` > 0 on all shards
3. Confirm transaction actually spans multiple shards (single-shard transactions don't need 2PC)

### Issue: Orphaned Prepared Transactions

**Symptom:** `pg_prepared_xacts` shows old prepared transactions

**Solution:**
```sql
-- On the affected shard
SELECT gid, prepared, owner, database FROM pg_prepared_xacts;

-- Manually commit or rollback
COMMIT PREPARED 'transaction_id';
-- or
ROLLBACK PREPARED 'transaction_id';
```

### Issue: Multi-Shard Query Blocked

**Symptom:** `ERROR: failed to match any datashard`

**Solutions:**
1. Use `__spqr__default_route_behaviour: allow` for the query
2. Use `__spqr__scatter_query: true` to broadcast
3. Provide a specific sharding key with `__spqr__sharding_key`
4. Use `__spqr__execute_on` to target a specific shard

## See Also

- [Routing Hints](/routing/hints) - Complete list of routing parameters
- [Router Configuration](/configuration/router) - Router settings including default routing behavior
- [Cross-Shard Queries](/features/cross_shard_queries) - Limitations and considerations for multi-shard queries
